; Zilog eZ80 ANSI C Compiler Release 3.4
; -optsize -noreduceopt -nomodsect -peephole -globalopt
; -localcse -const=ROM 
	FILE	"SRC\MCUFONT-DECODER\MF_WORDWRAP.C"
	.assume ADL=1
	SEGMENT CODE
;    1	#include "mf_wordwrap.h"
;    2	
;    3	/* Returns true if the line can be broken at this character. */
;    4	static bool is_wrap_space(uint16_t c)
;    5	{
_is_wrap_space:
	LD	HL,-3
	CALL	__frameset
;    6	    return c == ' ' || c == '\n' || c == '\t' || c == '\r' || c == '-';
	LD.LIS	BC,32
	LD	HL,(IX+6)
	OR	A,A
	SBC.SIS	HL,BC
	JR	Z,L_4
	LD.LIS	BC,10
	LD	HL,(IX+6)
	OR	A,A
	SBC.SIS	HL,BC
	JR	Z,L_4
	LD.LIS	BC,9
	LD	HL,(IX+6)
	OR	A,A
	SBC.SIS	HL,BC
	JR	Z,L_4
	LD.LIS	BC,13
	LD	HL,(IX+6)
	OR	A,A
	SBC.SIS	HL,BC
	JR	Z,L_4
	LD.LIS	BC,45
	LD	HL,(IX+6)
	OR	A,A
	SBC.SIS	HL,BC
	JR	NZ,L_5
L_4:
;    7	}
	LD	BC,1
	LD	(IX+-3),BC
	JR	L_6
L_5:
	LD	BC,0
	LD	(IX+-3),BC
L_6:
	LD	A,(IX+-3)
	LD	SP,IX
	POP	IX
	RET	


;**************************** _is_wrap_space ***************************
;Name                         Addr/Register   Size   Type
;temp7                                 IX-3      3   variable
;c                                     IX+6      2   parameter


; Stack Frame Size: 12 (bytes)
;       Spill Code: 0 (instruction)


;    8	
;    9	#if MF_USE_ADVANCED_WORDWRAP
;   10	
;   11	/* Represents a single word and the whitespace after it. */
;   12	struct wordlen_s
;   13	{
;   14	    int16_t word; /* Length of the word in pixels. */
;   15	    int16_t space; /* Length of the whitespace in pixels. */
;   16	    uint16_t chars; /* Number of characters in word + space, combined. */
;   17	};
;   18	
;   19	/* Take the next word from the string and compute its width.
;   20	 * Returns true if the word ends in a linebreak. */
;   21	static bool get_wordlen(const struct mf_font_s *font, mf_str *text,
;   22	                        struct wordlen_s *result)
;   23	{
_get_wordlen:
	LD	HL,-12
	CALL	__frameset
;   24	    mf_char c;
;   25	    mf_str prev = *text;
	LD	HL,(IX+9)
	LD	BC,(HL)
	LD	(IX+-5),BC
;   26	    
;   27	    result->word = 0;
	LD	IY,(IX+12)
	LD	(IY+0),0
	LD	(IY+1),0
;   28	    result->space = 0;
	LD	(IY+2),0
	LD	(IY+3),0
;   29	    result->chars = 0;
	LD	(IY+4),0
	LD	(IY+5),0
;   30	    
;   31	    c = mf_getchar(text);
	LD	BC,(IX+9)
	PUSH	BC
	CALL	_mf_getchar
	POP	BC
	LD	(IX+-2),L
	LD	(IX+-1),H
;   32	    while (c && !is_wrap_space(c))
	JR	L_11
L_12:
;   33	    {
;   34	        result->chars++;
	LD	IY,(IX+12)
	LD	BC,(IY+4)
	INC	BC
	LD	(IY+4),C
	LD	(IY+5),B
;   35	        result->word += mf_character_width(font, c);
	LD	DE,(IX+12)
	LD	BC,(IX+-2)
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	LD	(IX+-11),DE
	LD	(IX+-12),D
	CALL	_mf_character_width
	LD	DE,(IX+-11)
	LD	D,(IX+-12)
	POP	BC
	POP	BC
	LD	C,A
	LD	IY,DE
	LD	HL,(IY+0)
	LD	B,0
	ADD.SIS	HL,BC
	LD	BC,HL
	LD	IY,(IX+12)
	LD	(IY+0),C
	LD	(IY+1),B
;   36	
;   37	        prev = *text;
	LD	HL,(IX+9)
	LD	BC,(HL)
	LD	(IX+-5),BC
;   38	        c = mf_getchar(text);
	LD	BC,(IX+9)
	PUSH	BC
	CALL	_mf_getchar
	POP	BC
	LD	(IX+-2),L
	LD	(IX+-1),H
;   39	    }
L_11:
	LD	HL,(IX+-2)
	CALL	__scmpzero
	JR	Z,L_22
	LD	BC,(IX+-2)
	PUSH	BC
	CALL	_is_wrap_space
	POP	BC
	OR	A,A
	JR	NZ,L_22
	JR	L_12
;   40	    
;   41	    while (c && is_wrap_space(c))
L_23:
;   42	    {
;   43	        result->chars++;
	LD	IY,(IX+12)
	LD	BC,(IY+4)
	INC	BC
	LD	(IY+4),C
	LD	(IY+5),B
;   44	        
;   45	        if (c == ' ' || c == '-')
	LD	HL,(IX+-2)
	OR	A,A
	LD.LIS	BC,32
	SBC.SIS	HL,BC
	JR	Z,L_19
	LD.LIS	BC,45
	LD	HL,(IX+-2)
	OR	A,A
	SBC.SIS	HL,BC
	JR	NZ,L_20
L_19:
;   46	            result->space += mf_character_width(font, c);
	LD	DE,(IX+12)
	LD	BC,(IX+-2)
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	LD	(IX+-11),DE
	LD	(IX+-12),D
	CALL	_mf_character_width
	LD	DE,(IX+-11)
	LD	D,(IX+-12)
	POP	BC
	POP	BC
	LD	C,A
	LD	IY,DE
	LD	HL,(IY+2)
	LD	B,0
	ADD.SIS	HL,BC
	LD	BC,HL
	LD	IY,(IX+12)
	LD	(IY+2),C
	LD	(IY+3),B
;   47	        else if (c == '\t')
	JR	L_21
L_20:
	LD.LIS	BC,9
	LD	HL,(IX+-2)
	OR	A,A
	SBC.SIS	HL,BC
	JR	NZ,L_18
;   48	            result->space += mf_character_width(font, 'm') * MF_TABSIZE;
	LD	BC,109
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_mf_character_width
	POP	BC
	POP	BC
	LD	IY,(IX+12)
	LD	C,A
	LD	B,0
	LD	DE,(IY+2)
	LD	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD.SIS	HL,DE
	LD	BC,HL
	LD	(IY+2),C
	LD	(IY+3),B
;   49	        else if (c == '\n') {
	JR	L_21
L_18:
	LD.LIS	BC,10
	LD	HL,(IX+-2)
	OR	A,A
	SBC.SIS	HL,BC
	JR	NZ,L_21
;   50	            /* Special case for newlines, skip the character then break. */
;   51	            prev = *text;
	LD	HL,(IX+9)
	LD	BC,(HL)
	LD	(IX+-5),BC
;   52	            break;
	JR	L_26
;   53	        }
L_21:
;   54	        
;   55	        prev = *text;
	LD	HL,(IX+9)
	LD	BC,(HL)
	LD	(IX+-5),BC
;   56	        c = mf_getchar(text);
	LD	BC,(IX+9)
	PUSH	BC
	CALL	_mf_getchar
	POP	BC
	LD	(IX+-2),L
	LD	(IX+-1),H
;   57	    }
L_22:
	LD	HL,(IX+-2)
	CALL	__scmpzero
	JR	Z,L_26
	LD	BC,(IX+-2)
	PUSH	BC
	CALL	_is_wrap_space
	POP	BC
	OR	A,A
	JR	NZ,L_23
L_26:
;   58	    
;   59	    /* The last loop reads the first character of next word, put it back. */
;   60	    if (c)
	LD	HL,(IX+-2)
	CALL	__scmpzero
	JR	Z,L_32
;   61	        *text = prev;
	LD	HL,(IX+9)
	LD	BC,(IX+-5)
	LD	(HL),BC
L_32:
;   62	    
;   63	    return (c == '\0' || c == '\n');
	LD	HL,(IX+-2)
	CALL	__scmpzero
	JR	Z,L_28
	LD.LIS	BC,10
	LD	HL,(IX+-2)
	OR	A,A
	SBC.SIS	HL,BC
	JR	NZ,L_29
L_28:
;   64	}
	LD	BC,1
	LD	(IX+-8),BC
	JR	L_30
L_29:
	LD	BC,0
	LD	(IX+-8),BC
L_30:
	LD	A,(IX+-8)
	LD	SP,IX
	POP	IX
	RET	


;**************************** _get_wordlen ***************************
;Name                         Addr/Register   Size   Type
;_mf_character_width                 IMPORT  -----   function
;_mf_getchar                         IMPORT  -----   function
;temp31                                IX-8      3   variable
;prev                                  IX-5      3   variable
;c                                     IX-2      2   variable
;result                               IX+12      3   parameter
;text                                  IX+9      3   parameter
;font                                  IX+6      3   parameter


; Stack Frame Size: 27 (bytes)
;       Spill Code: 0 (instruction)


;   65	
;   66	/* Represents the rendered length for a single line. */
;   67	struct linelen_s
;   68	{
;   69	    mf_str start; /* Start of the text for line. */
;   70	    uint16_t chars; /* Total number of characters on the line. */
;   71	    int16_t width; /* Total length of all words + whitespace on the line in pixels. */
;   72	    bool linebreak; /* True if line ends in a linebreak */
;   73	    struct wordlen_s last_word; /* Last word on the line. */
;   74	    struct wordlen_s last_word_2; /* Second to last word on the line. */
;   75	};
;   76	
;   77	/* Append word onto the line if it fits. If it would overflow, don't add and
;   78	 * return false. */
;   79	static bool append_word(const struct mf_font_s *font, int16_t width,
;   80	                        struct linelen_s *current, mf_str *text)
;   81	{
_append_word:
	LD	HL,-10
	CALL	__frameset
;   82	    mf_str tmp = *text;
	LD	HL,(IX+15)
	LD	BC,(HL)
	LD	(IX+-10),BC
;   83	    struct wordlen_s wordlen;
;   84	    bool linebreak;
;   85	    
;   86	    linebreak = get_wordlen(font, &tmp, &wordlen);
	PEA	IX+-7
	PEA	IX+-10
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_get_wordlen
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-1),A
;   87	    
;   88	    if (current->width + wordlen.word <= width)
	LD	BC,(IX+-7)
	CALL	__stoi
	LD	IY,(IX+12)
	LD	BC,(IY+5)
	LD	DE,HL
	CALL	__stoi
	ADD	HL,DE
	LD	DE,HL
	LD	BC,(IX+9)
	CALL	__stoi
	OR	A,A
	SBC	HL,DE
	JP	M,L_35
;   89	    {
;   90	        *text = tmp;
	LD	HL,(IX+15)
	LD	BC,(IX+-10)
	LD	(HL),BC
;   91	        current->last_word_2 = current->last_word;
	LD	IY,(IX+12)
	LEA	DE,IY+14
	LEA	HL,IY+8
	LD	BC,6
	LDIR	
;   92	        current->last_word = wordlen;
	LEA	DE,IY+8
	LEA	HL,IX+-7
	LD	BC,6
	LDIR	
;   93	        current->linebreak = linebreak;
	LD	A,(IX+-1)
	LD	(IY+7),A
;   94	        current->chars += wordlen.chars;
	LD	BC,(IY+3)
	LD	HL,(IX+-3)
	ADD.SIS	HL,BC
	LD	BC,HL
	LD	(IY+3),C
	LD	(IY+4),B
;   95	        current->width += wordlen.word + wordlen.space;
	LD	DE,(IX+-5)
	LD	HL,(IX+-7)
	LD	BC,(IY+5)
	ADD.SIS	HL,DE
	ADD.SIS	HL,BC
	LD	BC,HL
	LD	(IY+5),C
	LD	(IY+6),B
;   96	        return true;
	LD	A,1
	JR	L_36
;   97	    }
;   98	    else
L_35:
;   99	    {
;  100	        return false;
	XOR	A,A
;  101	    }
;  102	}
L_36:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _append_word ***************************
;Name                         Addr/Register   Size   Type
;tmp                                  IX-10      3   variable
;wordlen                               IX-7      6   variable
;linebreak                             IX-1      1   variable
;text                                 IX+15      3   parameter
;current                              IX+12      3   parameter
;width                                 IX+9      2   parameter
;font                                  IX+6      3   parameter


; Stack Frame Size: 28 (bytes)
;       Spill Code: 0 (instruction)


;  103	
;  104	/* Append a character to the line if it fits. */
;  105	static bool append_char(const struct mf_font_s *font, int16_t width,
;  106	                        struct linelen_s *current, mf_str *text)
;  107	{
_append_char:
	LD	HL,-7
	CALL	__frameset
;  108	    mf_str tmp = *text;
	LD	HL,(IX+15)
	LD	BC,(HL)
	LD	(IX+-7),BC
;  109	    mf_char c;
;  110	    uint16_t w;
;  111	    
;  112	    c = mf_getchar(&tmp);
	PEA	IX+-7
	CALL	_mf_getchar
	POP	BC
	LD	(IX+-4),L
	LD	(IX+-3),H
;  113	    w = mf_character_width(font, c);
	LD	BC,(IX+-4)
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_mf_character_width
	POP	BC
	POP	BC
	LD	C,A
	LD	B,0
	LD	HL,BC
	LD	(IX+-2),L
	LD	(IX+-1),H
;  114	    
;  115	    if (current->width + w <= width)
	LD	IY,(IX+12)
	LD	BC,(IY+5)
	CALL	__stoi
	LD	DE,HL
	LD	BC,(IX+-2)
	CALL	__stoiu
	ADD	HL,DE
	LD	DE,HL
	LD	BC,(IX+9)
	CALL	__stoi
	OR	A,A
	SBC	HL,DE
	CALL	__setflag
	JP	M,L_39
;  116	    {
;  117	        *text = tmp;
	LD	HL,(IX+15)
	LD	BC,(IX+-7)
	LD	(HL),BC
;  118	        current->chars++;
	LD	IY,(IX+12)
	LD	BC,(IY+3)
	INC	BC
	LD	(IY+3),C
	LD	(IY+4),B
;  119	        current->width += w;
	LD	BC,(IX+-2)
	LD	HL,(IY+5)
	ADD.SIS	HL,BC
	LD	BC,HL
	LD	(IY+5),C
	LD	(IY+6),B
;  120	        return true;
	LD	A,1
	JR	L_40
;  121	    }
;  122	    else
L_39:
;  123	    {
;  124	        return false;
	XOR	A,A
;  125	    }
;  126	}
L_40:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _append_char ***************************
;Name                         Addr/Register   Size   Type
;_mf_character_width                 IMPORT  -----   function
;_mf_getchar                         IMPORT  -----   function
;tmp                                   IX-7      3   variable
;c                                     IX-4      2   variable
;w                                     IX-2      2   variable
;text                                 IX+15      3   parameter
;current                              IX+12      3   parameter
;width                                 IX+9      2   parameter
;font                                  IX+6      3   parameter


; Stack Frame Size: 25 (bytes)
;       Spill Code: 0 (instruction)


;  127	
;  128	/*static int16_t abs16(int16_t x) { return (x > 0) ? x : -x; }*/
;  129	static int32_t sq16(int16_t x) { return (int32_t)x * x; }
_sq16:
	LD	HL,-3
	CALL	__frameset
	LD	A,(IX+7)
	RLA	
	SBC	A,A
	LD	E,A
	LD	BC,(IX+6)
	CALL	__stoi
	LD	A,(IX+7)
	RLA	
	SBC	A,A
	LD	(IX+-3),HL
	LD	BC,(IX+6)
	CALL	__stoi
	LD	BC,HL
	LD	HL,(IX+-3)
	CALL	__lmuls
	LD	SP,IX
	POP	IX
	RET	


;**************************** _sq16 ***************************
;Name                         Addr/Register   Size   Type
;x                                     IX+6      2   parameter


; Stack Frame Size: 12 (bytes)
;       Spill Code: 0 (instruction)


;  130	
;  131	/* Try to balance the lines by potentially moving one word from the previous
;  132	 * line to the the current one. */
;  133	static void tune_lines(struct linelen_s *current, struct linelen_s *previous,
;  134	                       int16_t max_width)
;  135	{
_tune_lines:
	LD	HL,-32
	CALL	__frameset
;  136	    int16_t curw1, prevw1;
;  137	    int16_t curw2, prevw2;
;  138	    int32_t delta1, delta2;
;  139	    
;  140	    /* If the lines are rendered as is */
;  141	    curw1 = current->width - current->last_word.space;
	LD	IY,(IX+6)
	LD	BC,(IY+10)
	LD	HL,(IY+5)
	OR	A,A
	SBC.SIS	HL,BC
	LD	(IX+-13),L
	LD	(IX+-12),H
;  142	    prevw1 = previous->width - previous->last_word.space;
	LD	IY,(IX+9)
	LD	BC,(IY+10)
	LD	HL,(IY+5)
	OR	A,A
	SBC.SIS	HL,BC
	LD	(IX+-11),L
	LD	(IX+-10),H
;  143	    delta1 = sq16(max_width - prevw1) + sq16(max_width - curw1);
	LD	BC,(IX+-11)
	LD	HL,(IX+12)
	OR	A,A
	SBC.SIS	HL,BC
	PUSH	HL
	CALL	_sq16
	POP	BC
	LD	(IX+-31),HL
	LD	HL,(IX+12)
	LD	BC,(IX+-13)
	OR	A,A
	SBC.SIS	HL,BC
	PUSH	HL
	LD	(IX+-32),E
	CALL	_sq16
	POP	BC
	LD	A,E
	LD	BC,HL
	LD	HL,(IX+-31)
	LD	E,(IX+-32)
	CALL	__ladd
	LD	(IX+-17),HL
	LD	(IX+-14),E
;  144	    
;  145	    /* If the last word is moved */
;  146	    curw2 = current->width + previous->last_word.word;
	LD	IY,(IX+9)
	LEA	BC,IY+8
	LD	(IX+-3),BC
	LD	IY,(IX+-3)
	LD	BC,(IY+0)
	LD	IY,(IX+6)
	LD	HL,(IY+5)
	ADD.SIS	HL,BC
	LD	(IX+-7),L
	LD	(IX+-6),H
;  147	    prevw2 = previous->width - previous->last_word.word
;  148	                             - previous->last_word.space
;  149	                             - previous->last_word_2.space;
	LD	IY,(IX+-3)
	LD	BC,(IY+0)
	LD	HL,(IY+2)
	ADD.SIS	HL,BC
	LD	BC,HL
	LD	IY,(IX+9)
	LD	HL,(IY+16)
	ADD.SIS	HL,BC
	LD	BC,HL
	LD	HL,(IY+5)
	OR	A,A
	SBC.SIS	HL,BC
	LD	(IX+-9),L
	LD	(IX+-8),H
;  150	    delta2 = sq16(max_width - prevw2) + sq16(max_width - curw2);
	LD	BC,(IX+-9)
	LD	HL,(IX+12)
	OR	A,A
	SBC.SIS	HL,BC
	PUSH	HL
	CALL	_sq16
	POP	BC
	LD	(IX+-27),HL
	LD	HL,(IX+12)
	LD	BC,(IX+-7)
	OR	A,A
	SBC.SIS	HL,BC
	PUSH	HL
	LD	(IX+-28),E
	CALL	_sq16
	POP	BC
	LD	A,E
	LD	BC,HL
	LD	HL,(IX+-27)
	LD	E,(IX+-28)
	CALL	__ladd
	LD	(IX+-21),HL
	LD	(IX+-18),E
;  151	    
;  152	    if (delta1 > delta2 && curw2 <= max_width)
	LD	HL,(IX+-21)
	LD	E,(IX+-18)
	LD	BC,(IX+-17)
	LD	A,(IX+-14)
	CALL	__lcmps
	CALL	__setflag
	JP	P,L_47
	LD	BC,(IX+-7)
	LD	HL,(IX+12)
	OR	A,A
	SBC.SIS	HL,BC
	CALL	__setflag
	JP	M,L_47
;  153	    {
;  154	        /* Do the change. */
;  155	        uint16_t chars;
;  156	        
;  157	        chars = previous->last_word.chars;
	LD	IY,(IX+9)
	LD	BC,(IY+12)
	LD	(IX+-5),C
	LD	(IX+-4),B
;  158	        previous->chars -= chars;
	LD	BC,(IX+-5)
	LD	HL,(IY+3)
	OR	A,A
	SBC.SIS	HL,BC
	LD	BC,HL
	LD	(IY+3),C
	LD	(IY+4),B
;  159	        current->chars += chars;
	LD	BC,(IX+-5)
	LD	IY,(IX+6)
	LD	HL,(IY+3)
	ADD.SIS	HL,BC
	LD	BC,HL
	LD	(IY+3),C
	LD	(IY+4),B
;  160	        previous->width -= previous->last_word.word + previous->last_word.space;
	LD	IY,(IX+9)
	LEA	BC,IY+8
	LD	(IX+-24),BC
	LD	IY,(IX+-24)
	LD	BC,(IY+2)
	LD	HL,(IY+0)
	ADD.SIS	HL,BC
	LD	BC,HL
	LD	IY,(IX+9)
	LD	HL,(IY+5)
	OR	A,A
	SBC.SIS	HL,BC
	LD	BC,HL
	LD	(IY+5),C
	LD	(IY+6),B
;  161	        current->width += previous->last_word.word + previous->last_word.space;
	LD	IY,(IX+-24)
	LD	BC,(IY+2)
	LD	HL,(IY+0)
	ADD.SIS	HL,BC
	LD	IY,(IX+6)
	LD	BC,(IY+5)
	ADD.SIS	HL,BC
	LD	BC,HL
	LD	(IY+5),C
	LD	(IY+6),B
;  162	        previous->last_word = previous->last_word_2;
	LD	DE,(IX+-24)
	LD	IY,(IX+9)
	LEA	HL,IY+14
	LD	BC,6
	LDIR	
;  163	        
;  164	        while (chars--) mf_rewind(&current->start);
	JR	L_44
L_45:
	LD	IY,(IX+6)
	PEA	IY+0
	CALL	_mf_rewind
	POP	BC
L_44:
	LD	IY,(IX+-5)
	LEA	HL,IY+-1
	LD	BC,(IX+-5)
	LD	(IX+-5),L
	LD	(IX+-4),H
	LD	HL,BC
	CALL	__scmpzero
	JR	NZ,L_45
;  165	    }
;  166	}
L_47:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _tune_lines ***************************
;Name                         Addr/Register   Size   Type
;_mf_rewind                          IMPORT  -----   function
;delta2                               IX-21      4   variable
;delta1                               IX-17      4   variable
;curw1                                IX-13      2   variable
;prevw1                               IX-11      2   variable
;prevw2                                IX-9      2   variable
;curw2                                 IX-7      2   variable
;chars                                 IX-5      2   variable
;max_width                            IX+12      2   parameter
;previous                              IX+9      3   parameter
;current                               IX+6      3   parameter


; Stack Frame Size: 47 (bytes)
;       Spill Code: 0 (instruction)


;  167	
;  168	void mf_wordwrap(const struct mf_font_s *font, int16_t width,
;  169	                 mf_str text, mf_line_callback_t callback, void *state)
;  170	{
_mf_wordwrap:
	LD	HL,-47
	CALL	__frameset
;  171	    struct linelen_s current = { 0 };
	LEA	DE,IX+-24
	LD	HL,_0temp48
	LD	BC,20
	LDIR	
;  172	    struct linelen_s previous = { 0 };
	LEA	DE,IX+-44
	LD	HL,_1temp49
	LD	BC,20
	LDIR	
;  173	    bool full;
;  174	    
;  175	    current.start = text;
	LD	BC,(IX+12)
	LD	(IX+-24),BC
;  176	    
;  177	    while (*text)
	JR	L_66
L_67:
;  178	    {
;  179	        full = !append_word(font, width, &current, &text);
	PEA	IX+12
	PEA	IX+-24
	LD	BC,(IX+9)
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_append_word
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	OR	A,A
	JR	NZ,L_51
	LD	BC,1
	LD	(IX+-4),BC
	JR	L_52
L_51:
	LD	BC,0
	LD	(IX+-4),BC
L_52:
	LD	A,(IX+-4)
	LD	(IX+-1),A
;  180	        
;  181	        if (full || current.linebreak)
	OR	A,A
	JR	NZ,L_65
	LD	A,(IX+-17)
	OR	A,A
	JR	Z,L_66
L_65:
;  182	        {
;  183	            if (!current.chars)
	LD	HL,(IX+-21)
	CALL	__scmpzero
	JR	NZ,L_63
;  184	            {
;  185	                /* We have a very long word. We must just cut it off at some
;  186	                 * point. */
;  187	                while (append_char(font, width, &current, &text));
L_56:
	PEA	IX+12
	PEA	IX+-24
	LD	BC,(IX+9)
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_append_char
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	OR	A,A
	JR	NZ,L_56
;  188	            }
L_63:
;  189	            
;  190	            if (previous.chars)
	LD	HL,(IX+-41)
	CALL	__scmpzero
	JR	Z,L_64
;  191	            {
;  192	                /* Tune the length and dispatch the previous line. */
;  193	                if (!previous.linebreak && !current.linebreak)
	LD	A,(IX+-37)
	OR	A,A
	JR	NZ,L_61
	LD	A,(IX+-17)
	OR	A,A
	JR	NZ,L_61
;  194	                    tune_lines(&current, &previous, width);
	LD	BC,(IX+9)
	PUSH	BC
	PEA	IX+-44
	PEA	IX+-24
	CALL	_tune_lines
	POP	BC
	POP	BC
	POP	BC
L_61:
;  195	                
;  196	                if (!callback(previous.start, previous.chars, state))
	LD	IY,(IX+15)
	LD	BC,(IX+18)
	PUSH	BC
	LD	BC,(IX+-41)
	PUSH	BC
	LD	BC,(IX+-44)
	PUSH	BC
	CALL	__indcall
	POP	BC
	POP	BC
	POP	BC
	OR	A,A
	JR	Z,L_73
;  197	                    return;
;  198	            }
L_64:
;  199	            
;  200	            previous = current;
	LEA	DE,IX+-44
	LEA	HL,IX+-24
	LD	BC,20
	LDIR	
;  201	            current.start = text;
	LD	BC,(IX+12)
	LD	(IX+-24),BC
;  202	            current.chars = 0;
	LD	(IX+-21),0
	LD	(IX+-20),0
;  203	            current.width = 0;
	LD	(IX+-19),0
	LD	(IX+-18),0
;  204	            current.linebreak = false;
	LD	(IX+-17),0
;  205	            current.last_word.word = 0;
	LEA	BC,IX+-16
	LD	(IX+-47),BC
	LD	IY,(IX+-47)
	LD	(IY+0),0
	LD	(IY+1),0
;  206	            current.last_word.space = 0;
	LD	(IY+2),0
	LD	(IY+3),0
;  207	            current.last_word.chars = 0;
	LD	(IY+4),0
	LD	(IY+5),0
;  208	        }
;  209	    }
L_66:
	LD	HL,(IX+12)
	LD	A,(HL)
	OR	A,A
	JR	NZ,L_67
;  210	    
;  211	    /* Dispatch the last lines. */
;  212	    if (previous.chars)
	LD	HL,(IX+-41)
	CALL	__scmpzero
	JR	Z,L_72
;  213	    {
;  214	        if (!callback(previous.start, previous.chars, state))
	LD	IY,(IX+15)
	LD	BC,(IX+18)
	PUSH	BC
	LD	BC,(IX+-41)
	PUSH	BC
	LD	BC,(IX+-44)
	PUSH	BC
	CALL	__indcall
	POP	BC
	POP	BC
	POP	BC
	OR	A,A
	JR	Z,L_73
;  215	            return;
;  216	    }
L_72:
;  217	    
;  218	    if (current.chars)
	LD	HL,(IX+-21)
	CALL	__scmpzero
	JR	Z,L_73
;  219	        callback(current.start, current.chars, state);
	LD	IY,(IX+15)
	LD	BC,(IX+18)
	PUSH	BC
	LD	BC,(IX+-21)
	PUSH	BC
	LD	BC,(IX+-24)
	PUSH	BC
	CALL	__indcall
	POP	BC
	POP	BC
	POP	BC
;  220	}
L_73:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _mf_wordwrap ***************************
;Name                         Addr/Register   Size   Type
;_1temp49                            STATIC     20   variable
;_0temp48                            STATIC     20   variable
;previous                             IX-44     20   variable
;current                              IX-24     20   variable
;temp53                                IX-4      3   variable
;full                                  IX-1      1   variable
;state                                IX+18      3   parameter
;callback                             IX+15      3   parameter
;text                                 IX+12      3   parameter
;width                                 IX+9      2   parameter
;font                                  IX+6      3   parameter


; Stack Frame Size: 68 (bytes)
;       Spill Code: 0 (instruction)


	SEGMENT TEXT
_0temp48:
	DW24	0
	DW	0
	DW	0
	DB	0
	DW	0
	DW	0
	DW	0
	DW	0
	DW	0
	DW	0
_1temp49:
	DW24	0
	DW	0
	DW	0
	DB	0
	DW	0
	DW	0
	DW	0
	DW	0
	DW	0
	DW	0
	XREF _mf_character_width:ROM
	XREF _mf_rewind:ROM
	XREF _mf_getchar:ROM
	XREF __indcall:ROM
	XREF __lcmps:ROM
	XREF __ladd:ROM
	XREF __lmuls:ROM
	XREF __stoi:ROM
	XREF __stoiu:ROM
	XREF __frameset:ROM
	XREF __setflag:ROM
	XREF __scmpzero:ROM
	XDEF _mf_wordwrap
	END
