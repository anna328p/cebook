; Zilog eZ80 ANSI C Compiler Release 3.4
; -optsize -noreduceopt -nomodsect -peephole -globalopt
; -localcse -const=ROM 
	FILE	"SRC\MCUFONT-DECODER\MF_KERNING.C"
	.assume ADL=1
	SEGMENT CODE
;    1	#include "mf_kerning.h"
;    2	#include <stdbool.h>
;    3	
;    4	#if MF_USE_KERNING
;    5	
;    6	/* Structure for keeping track of the edge of the glyph as it is rendered. */
;    7	struct kerning_state_s
;    8	{
;    9	    uint8_t edgepos[MF_KERNING_ZONES];
;   10	    uint8_t zoneheight;
;   11	};
;   12	
;   13	/* Pixel callback for analyzing the left edge of a glyph. */
;   14	static void fit_leftedge(int16_t x, int16_t y, uint8_t count, uint8_t alpha,
;   15	                         void *state)
;   16	{
_fit_leftedge:
	LD	HL,-4
	CALL	__frameset
;   17	    struct kerning_state_s *s = state;
;   18	    
;   19	    if (alpha > 7)
	LD	A,7
	CP	A,(IX+15)
	JR	NC,L_2
;   20	    {
;   21	        uint8_t zone = y / s->zoneheight;
	LD	BC,(IX+9)
	CALL	__stoi
	LD	IY,(IX+18)
	LD	A,(IY+8)
	LD	DE,HL
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,DE
	CALL	__idivs
	LD	(IX+-1),L
;   22	        if (x < s->edgepos[zone])
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LEA	HL,IY+0
	ADD	HL,BC
	LD	(IX+-4),HL
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	DE,HL
	LD	BC,(IX+6)
	CALL	__stoi
	OR	A,A
	SBC	HL,DE
	CALL	__setflag
	JP	P,L_2
;   23	            s->edgepos[zone] = x;
	LD	A,(IX+6)
	LD	HL,(IX+-4)
	LD	(HL),A
;   24	    }
;   25	}
L_2:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _fit_leftedge ***************************
;Name                         Addr/Register   Size   Type
;G_0                                   IX-4      3   variable
;zone                                  IX-1      1   variable
;state                                IX+18      3   parameter
;alpha                                IX+15      1   parameter
;count                                IX+12      1   parameter
;y                                     IX+9      2   parameter
;x                                     IX+6      2   parameter


; Stack Frame Size: 25 (bytes)
;       Spill Code: 0 (instruction)


;   26	
;   27	/* Pixel callback for analyzing the right edge of a glyph. */
;   28	static void fit_rightedge(int16_t x, int16_t y, uint8_t count, uint8_t alpha,
;   29	                         void *state)
;   30	{
_fit_rightedge:
	LD	HL,-4
	CALL	__frameset
;   31	    struct kerning_state_s *s = state;
;   32	    
;   33	    if (alpha > 7)
	LD	A,7
	CP	A,(IX+15)
	JR	NC,L_5
;   34	    {
;   35	        uint8_t zone = y / s->zoneheight;
	LD	BC,(IX+9)
	CALL	__stoi
	LD	IY,(IX+18)
	LD	A,(IY+8)
	LD	DE,HL
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,DE
	CALL	__idivs
	LD	(IX+-1),L
;   36	        x += count - 1;
	LD	C,(IX+12)
	LD	B,0
	DEC	BC
	LD	HL,BC
	LD	BC,(IX+6)
	ADD.SIS	HL,BC
	LD	(IX+6),L
	LD	(IX+7),H
;   37	        if (x > s->edgepos[zone])
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LEA	HL,IY+0
	ADD	HL,BC
	LD	(IX+-4),HL
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	DE,HL
	LD	BC,(IX+6)
	CALL	__stoi
	LD	BC,HL
	LD	HL,DE
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_5
;   38	            s->edgepos[zone] = x;
	LD	A,(IX+6)
	LD	HL,(IX+-4)
	LD	(HL),A
;   39	    }
;   40	}
L_5:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _fit_rightedge ***************************
;Name                         Addr/Register   Size   Type
;G_1                                   IX-4      3   variable
;zone                                  IX-1      1   variable
;state                                IX+18      3   parameter
;alpha                                IX+15      1   parameter
;count                                IX+12      1   parameter
;y                                     IX+9      2   parameter
;x                                     IX+6      2   parameter


; Stack Frame Size: 25 (bytes)
;       Spill Code: 0 (instruction)


;   41	
;   42	/* Should kerning be done against this character? */
;   43	static bool do_kerning(mf_char c)
;   44	{
_do_kerning:
	CALL	__frameset0
;   45	    /* Just a speed optimization, spaces would be ignored anyway. */
;   46	    if (c == ' ' || c == '\n' || c == '\r' || c == '\t')
	LD.LIS	BC,32
	LD	HL,(IX+6)
	OR	A,A
	SBC.SIS	HL,BC
	JR	Z,L_9
	LD.LIS	BC,10
	LD	HL,(IX+6)
	OR	A,A
	SBC.SIS	HL,BC
	JR	Z,L_9
	LD.LIS	BC,13
	LD	HL,(IX+6)
	OR	A,A
	SBC.SIS	HL,BC
	JR	Z,L_9
	LD.LIS	BC,9
	LD	HL,(IX+6)
	OR	A,A
	SBC.SIS	HL,BC
	JR	NZ,L_12
L_9:
;   47	        return false;
	XOR	A,A
	JR	L_14
L_12:
;   48	    
;   49	    /* Do not kern against digits, in order to keep values in tables nicely
;   50	     * aligned. Most fonts have constant width for digits. */
;   51	    if (c >= '0' && c <= '9')
	LD.LIS	BC,48
	LD	HL,(IX+6)
	OR	A,A
	SBC.SIS	HL,BC
	JR	C,L_13
	LD	BC,(IX+6)
	LD.LIS	HL,57
	OR	A,A
	SBC.SIS	HL,BC
	JR	C,L_13
;   52	        return false;
	XOR	A,A
	JR	L_14
L_13:
;   53	    
;   54	    return true;
	LD	A,1
;   55	}
L_14:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _do_kerning ***************************
;Name                         Addr/Register   Size   Type
;c                                     IX+6      2   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


;   56	
;   57	/*static int16_t min16(int16_t a, int16_t b) { return (a < b) ? a : b; }*/
;   58	static int16_t max16(int16_t a, int16_t b) { return (a > b) ? a : b; }
_max16:
	LD	HL,-3
	CALL	__frameset
	LD	BC,(IX+6)
	LD	HL,(IX+9)
	OR	A,A
	SBC.SIS	HL,BC
	CALL	__setflag
	JP	P,L_17
	LD	BC,(IX+6)
	CALL	__stoi
	LD	(IX+-3),HL
	JR	L_18
L_17:
	LD	BC,(IX+9)
	CALL	__stoi
	LD	(IX+-3),HL
L_18:
	LD	HL,(IX+-3)
	LD	SP,IX
	POP	IX
	RET	


;**************************** _max16 ***************************
;Name                         Addr/Register   Size   Type
;temp15                                IX-3      3   variable
;b                                     IX+9      2   parameter
;a                                     IX+6      2   parameter


; Stack Frame Size: 15 (bytes)
;       Spill Code: 0 (instruction)


;   59	static int16_t avg16(int16_t a, int16_t b) { return (a + b) / 2; }
_avg16:
	CALL	__frameset0
	LD	BC,(IX+6)
	CALL	__stoi
	LD	DE,HL
	LD	BC,(IX+9)
	CALL	__stoi
	ADD	HL,DE
	LD	BC,2
	CALL	__idivs
	LD	SP,IX
	POP	IX
	RET	


;**************************** _avg16 ***************************
;Name                         Addr/Register   Size   Type
;b                                     IX+9      2   parameter
;a                                     IX+6      2   parameter


; Stack Frame Size: 12 (bytes)
;       Spill Code: 0 (instruction)


;   60	
;   61	int8_t mf_compute_kerning(const struct mf_font_s *font,
;   62	                          mf_char c1, mf_char c2)
;   63	{
_mf_compute_kerning:
	LD	HL,-35
	CALL	__frameset
;   64	    struct kerning_state_s leftedge, rightedge;
;   65	    uint8_t w1, w2, i, min_space;
;   66	    int16_t normal_space, adjust, max_adjust;
;   67	    
;   68	    if (font->flags & MF_FONT_FLAG_MONOSPACE)
	LD	IY,(IX+6)
	LD	A,(IY+13)
	AND	A,1
	JR	Z,L_24
;   69	        return 0; /* No kerning for monospace fonts */
	XOR	A,A
	JR	L_48
L_24:
;   70	    
;   71	    if (!do_kerning(c1) || !do_kerning(c2))
	LD	BC,(IX+9)
	PUSH	BC
	CALL	_do_kerning
	POP	BC
	OR	A,A
	JR	Z,L_23
	LD	BC,(IX+12)
	PUSH	BC
	CALL	_do_kerning
	POP	BC
	OR	A,A
	JR	NZ,L_25
L_23:
;   72	        return 0;
	XOR	A,A
	JR	L_48
L_25:
;   73	    
;   74	    /* Compute the height of one kerning zone in pixels */
;   75	    i = (font->height + MF_KERNING_ZONES - 1) / MF_KERNING_ZONES;
	LD	IY,(IX+6)
	LD	A,(IY+7)
	UEXT	HL
	LD	L,A
	LD	IY,HL
	LEA	HL,IY+7
	LD	BC,8
	CALL	__idivs
	LD	(IX+-1),L
;   76	    if (i < 1) i = 1;
	LD	A,(IX+-1)
	CP	A,1
	JR	NC,L_27
	LD	(IX+-1),1
L_27:
;   77	    
;   78	    /* Initialize structures */
;   79	    leftedge.zoneheight = rightedge.zoneheight = i;
	LD	A,(IX+-1)
	LD	(IX+-18),A
	LD	(IX+-27),A
;   80	    for (i = 0; i < MF_KERNING_ZONES; i++)
	LD	(IX+-1),0
	JR	L_31
L_29:
;   81	    {
;   82	        leftedge.edgepos[i] = 255;
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LEA	HL,IX+-35
	ADD	HL,BC
	LD	(HL),255
;   83	        rightedge.edgepos[i] = 0;
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LEA	HL,IX+-26
	ADD	HL,BC
	LD	(HL),0
	INC	(IX+-1)
;   84	    }
L_31:
	LD	A,(IX+-1)
	CP	A,8
	JR	C,L_29
;   85	    
;   86	    /* Analyze the edges of both glyphs. */
;   87	    w1 = mf_render_character(font, 0, 0, c1, fit_rightedge, &rightedge);
	PEA	IX+-26
	LD	BC,_fit_rightedge
	PUSH	BC
	LD	BC,(IX+9)
	PUSH	BC
	LD	BC,0
	PUSH	BC
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_mf_render_character
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-5),A
;   88	    w2 = mf_render_character(font, 0, 0, c2, fit_leftedge, &leftedge);
	PEA	IX+-35
	LD	BC,_fit_leftedge
	PUSH	BC
	LD	BC,(IX+12)
	PUSH	BC
	LD	BC,0
	PUSH	BC
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_mf_render_character
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-8),A
;   89	    
;   90	    /* Find the minimum horizontal space between the glyphs. */
;   91	    min_space = 255;
	LD	(IX+-2),255
;   92	    for (i = 0; i < MF_KERNING_ZONES; i++)
	LD	(IX+-1),0
	JR	L_40
L_38:
;   93	    {
;   94	        uint8_t space;
;   95	        if (leftedge.edgepos[i] == 255 || rightedge.edgepos[i] == 0)
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LEA	HL,IX+-35
	ADD	HL,BC
	LD	(IX+-14),HL
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	OR	A,A
	LD	BC,255
	SBC	HL,BC
	JR	Z,L_39
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LEA	HL,IX+-26
	ADD	HL,BC
	LD	(IX+-17),HL
	LD	A,(HL)
	OR	A,A
	JR	Z,L_39
;   96	            continue; /* Outside glyph area. */
;   97	        
;   98	        space = w1 - rightedge.edgepos[i] + leftedge.edgepos[i];
	LD	HL,(IX+-17)
	LD	A,(IX+-5)
	SUB	A,(HL)
	LD	HL,(IX+-14)
	ADD	A,(HL)
	LD	(IX+-9),A
;   99	        if (space < min_space)
	CP	A,(IX+-2)
	JR	NC,L_39
;  100	            min_space = space;
	LD	A,(IX+-9)
	LD	(IX+-2),A
;  101	    }
L_39:
	INC	(IX+-1)
L_40:
	LD	A,(IX+-1)
	CP	A,8
	JR	C,L_38
;  102	    
;  103	    if (min_space == 255)
	LD	A,(IX+-2)
	CP	A,255
	JR	NZ,L_43
;  104	        return 0; /* One of the characters is space, or both are punctuation. */
	XOR	A,A
	JR	L_48
L_43:
;  105	    
;  106	    /* Compute the adjustment of the glyph position. */
;  107	    normal_space = avg16(w1, w2) * MF_KERNING_SPACE_PERCENT / 100;
	LD	C,(IX+-8)
	LD	B,0
	PUSH	BC
	LD	C,(IX+-5)
	PUSH	BC
	CALL	_avg16
	POP	BC
	POP	BC
	LD	BC,HL
	CALL	__stoi
	LD	A,15
	CALL	__imul_b
	LD	BC,100
	CALL	__idivs
	LD	(IX+-7),L
	LD	(IX+-6),H
;  108	    normal_space += MF_KERNING_SPACE_PIXELS;
	LD	IY,(IX+-7)
	LEA	HL,IY+3
	LD	(IX+-7),L
	LD	(IX+-6),H
;  109	    adjust = normal_space - min_space;
	LD	C,(IX+-2)
	LD	B,0
	LD	HL,(IX+-7)
	OR	A,A
	SBC.SIS	HL,BC
	LD	(IX+-4),L
	LD	(IX+-3),H
;  110	    max_adjust = -max16(w1, w2) * MF_KERNING_LIMIT / 100;
	LD	C,(IX+-8)
	PUSH	BC
	LD	C,(IX+-5)
	PUSH	BC
	CALL	_max16
	POP	BC
	POP	BC
	LD	BC,HL
	CALL	__stoi
	CALL	__ineg
	LD	A,20
	CALL	__imul_b
	LD	BC,100
	CALL	__idivs
	LD	(IX+-11),L
	LD	(IX+-10),H
;  111	    
;  112	    if (adjust > 0) adjust = 0;
	LD	BC,(IX+-4)
	OR	A,A
	SBC	HL,HL
	OR	A,A
	SBC.SIS	HL,BC
	JP	P,L_46
	LD	(IX+-4),0
	LD	(IX+-3),0
L_46:
;  113	    if (adjust < max_adjust) adjust = max_adjust;
	LD	BC,(IX+-11)
	LD	HL,(IX+-4)
	OR	A,A
	SBC.SIS	HL,BC
	CALL	__setflag
	JP	P,L_47
	LD	BC,(IX+-11)
	LD	(IX+-4),C
	LD	(IX+-3),B
L_47:
;  114	    
;  115	    return adjust;
	LD	A,(IX+-4)
;  116	}
L_48:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _mf_compute_kerning ***************************
;Name                         Addr/Register   Size   Type
;_mf_render_character                IMPORT  -----   function
;leftedge                             IX-35      9   variable
;rightedge                            IX-26      9   variable
;G_2                                  IX-17      3   variable
;G_3                                  IX-14      3   variable
;max_adjust                           IX-11      2   variable
;space                                 IX-9      1   variable
;w2                                    IX-8      1   variable
;normal_space                          IX-7      2   variable
;w1                                    IX-5      1   variable
;adjust                                IX-4      2   variable
;min_space                             IX-2      1   variable
;i                                     IX-1      1   variable
;c2                                   IX+12      2   parameter
;c1                                    IX+9      2   parameter
;font                                  IX+6      3   parameter


; Stack Frame Size: 50 (bytes)
;       Spill Code: 0 (instruction)


	XREF _mf_render_character:ROM
	XREF __idivs:ROM
	XREF __ineg:ROM
	XREF __stoi:ROM
	XREF __frameset0:ROM
	XREF __frameset:ROM
	XREF __setflag:ROM
	XREF __imul_b:ROM
	XDEF _mf_compute_kerning
	END
