; Zilog eZ80 ANSI C Compiler Release 3.4
; -optsize -noreduceopt -nomodsect -peephole -globalopt
; -localcse -const=ROM 
	FILE	"SRC\MCUFONT-DECODER\MF_JUSTIFY.C"
	.assume ADL=1
	SEGMENT CODE
;    1	#include "mf_justify.h"
;    2	#include "mf_kerning.h"
;    3	
;    4	#if MF_USE_TABS
;    5	/* Round the X coordinate up to the nearest tab stop. */
;    6	static int16_t mf_round_to_tab(const struct mf_font_s *font,
;    7	                               int16_t x0, int16_t x)
;    8	{
_mf_round_to_tab:
	LD	HL,-4
	CALL	__frameset
;    9	    int16_t tabw, dx;
;   10	    
;   11	    tabw = mf_character_width(font, 'm') * MF_TABSIZE;
	LD	BC,109
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_mf_character_width
	POP	BC
	POP	BC
	LD	C,A
	LD	B,0
	LD	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	(IX+-2),L
	LD	(IX+-1),H
;   12	    
;   13	    /* Always atleast 1 space */
;   14	    x += mf_character_width(font, ' ');
	LD	BC,32
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_mf_character_width
	POP	BC
	POP	BC
	LD	C,A
	LD	B,0
	LD	HL,BC
	LD	BC,(IX+12)
	ADD.SIS	HL,BC
	LD	(IX+12),L
	LD	(IX+13),H
;   15	    
;   16	    /* Round to next tab stop */
;   17	    dx = x - x0 + font->baseline_x;
	LD	IY,(IX+6)
	LD	A,(IY+10)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	DE,HL
	LD	HL,(IX+12)
	OR	A,A
	LD	BC,(IX+9)
	SBC.SIS	HL,BC
	LD	BC,HL
	LD	HL,DE
	ADD.SIS	HL,BC
	LD	(IX+-4),L
	LD	(IX+-3),H
;   18	    x += tabw - (dx % tabw);
	LD	BC,(IX+-4)
	CALL	__stoi
	LD	DE,HL
	LD	BC,(IX+-2)
	CALL	__stoi
	LD	BC,HL
	LD	HL,DE
	CALL	__irems
	LD	BC,HL
	LD	HL,(IX+-2)
	OR	A,A
	SBC.SIS	HL,BC
	LD	BC,(IX+12)
	ADD.SIS	HL,BC
	LD	(IX+12),L
	LD	(IX+13),H
;   19	    
;   20	    return x;
	LD	HL,(IX+12)
;   21	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _mf_round_to_tab ***************************
;Name                         Addr/Register   Size   Type
;_mf_character_width                 IMPORT  -----   function
;dx                                    IX-4      2   variable
;tabw                                  IX-2      2   variable
;x                                    IX+12      2   parameter
;x0                                    IX+9      2   parameter
;font                                  IX+6      3   parameter


; Stack Frame Size: 19 (bytes)
;       Spill Code: 0 (instruction)


;   22	
;   23	/* Round the X coordinate down to the nearest tab stop. */
;   24	static int16_t mf_round_to_prev_tab(const struct mf_font_s *font,
;   25	                                    int16_t x0, int16_t x)
;   26	{
_mf_round_to_prev_tab:
	LD	HL,-4
	CALL	__frameset
;   27	    int16_t tabw, dx;
;   28	    
;   29	    tabw = mf_character_width(font, 'm') * MF_TABSIZE;
	LD	BC,109
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_mf_character_width
	POP	BC
	POP	BC
	LD	C,A
	LD	B,0
	LD	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	(IX+-2),L
	LD	(IX+-1),H
;   30	    
;   31	    /* Always atleast 1 space */
;   32	    x -= mf_character_width(font, ' ');
	LD	BC,32
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_mf_character_width
	POP	BC
	POP	BC
	LD	C,A
	LD	B,0
	LD	HL,(IX+12)
	OR	A,A
	SBC.SIS	HL,BC
	LD	(IX+12),L
	LD	(IX+13),H
;   33	    
;   34	    /* Round to previous tab stop */
;   35	    dx = x0 - x + font->baseline_x;
	LD	IY,(IX+6)
	LD	A,(IY+10)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	DE,HL
	LD	HL,(IX+9)
	OR	A,A
	LD	BC,(IX+12)
	SBC.SIS	HL,BC
	LD	BC,HL
	LD	HL,DE
	ADD.SIS	HL,BC
	LD	(IX+-4),L
	LD	(IX+-3),H
;   36	    x -= tabw - (dx % tabw);
	LD	BC,(IX+-4)
	CALL	__stoi
	LD	DE,HL
	LD	BC,(IX+-2)
	CALL	__stoi
	LD	BC,HL
	LD	HL,DE
	CALL	__irems
	LD	BC,HL
	LD	HL,(IX+-2)
	OR	A,A
	SBC.SIS	HL,BC
	LD	BC,HL
	LD	HL,(IX+12)
	OR	A,A
	SBC.SIS	HL,BC
	LD	(IX+12),L
	LD	(IX+13),H
;   37	    
;   38	    return x;
	LD	HL,(IX+12)
;   39	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _mf_round_to_prev_tab ***************************
;Name                         Addr/Register   Size   Type
;_mf_character_width                 IMPORT  -----   function
;dx                                    IX-4      2   variable
;tabw                                  IX-2      2   variable
;x                                    IX+12      2   parameter
;x0                                    IX+9      2   parameter
;font                                  IX+6      3   parameter


; Stack Frame Size: 19 (bytes)
;       Spill Code: 0 (instruction)


;   40	#endif
;   41	
;   42	int16_t mf_get_string_width(const struct mf_font_s *font, mf_str text,
;   43	                            uint16_t count, bool kern)
;   44	{
_mf_get_string_width:
	LD	HL,-6
	CALL	__frameset
;   45	    int16_t result = 0;
	LD	(IX+-2),0
	LD	(IX+-1),0
;   46	    uint16_t c1 = 0, c2;
	LD	(IX+-4),0
	LD	(IX+-3),0
;   47	    
;   48	    if (!count)
	LD	HL,(IX+12)
	CALL	__scmpzero
	JR	NZ,L_10
;   49	        count = 0xFFFF;
	LD	(IX+12),255
	LD	(IX+13),255
;   50	    
;   51	    while (count-- && *text)
	JR	L_10
L_11:
;   52	    {
;   53	        c2 = mf_getchar(&text);
	PEA	IX+9
	CALL	_mf_getchar
	POP	BC
	LD	(IX+-6),L
	LD	(IX+-5),H
;   54	
;   55	        if (c2 == '\t')
	LD	HL,(IX+-6)
	LD.LIS	BC,9
	OR	A,A
	SBC.SIS	HL,BC
	JR	NZ,L_8
;   56	        {
;   57	#if MF_USE_TABS
;   58	            result = mf_round_to_tab(font, 0, result);
	LD	BC,(IX+-2)
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_mf_round_to_tab
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-2),L
	LD	(IX+-1),H
;   59	            c1 = ' ';
	LD	(IX+-4),32
	LD	(IX+-3),0
;   60	            continue;
	JR	L_10
;   61	#else
;   62	            c2 = ' ';
;   63	#endif
;   64	        }
L_8:
;   65	        
;   66	        if (kern && c1 != 0)
	LD	A,(IX+15)
	OR	A,A
	JR	Z,L_9
	LD	HL,(IX+-4)
	CALL	__scmpzero
	JR	Z,L_9
;   67	            result += mf_compute_kerning(font, c1, c2);
	LD	BC,(IX+-6)
	PUSH	BC
	LD	BC,(IX+-4)
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_mf_compute_kerning
	POP	BC
	POP	BC
	POP	BC
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,(IX+-2)
	ADD.SIS	HL,BC
	LD	(IX+-2),L
	LD	(IX+-1),H
L_9:
;   68	
;   69	        result += mf_character_width(font, c2);
	LD	BC,(IX+-6)
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_mf_character_width
	POP	BC
	POP	BC
	LD	C,A
	LD	B,0
	LD	HL,BC
	LD	BC,(IX+-2)
	ADD.SIS	HL,BC
	LD	(IX+-2),L
	LD	(IX+-1),H
;   70	        c1 = c2;
	LD	BC,(IX+-6)
	LD	(IX+-4),C
	LD	(IX+-3),B
;   71	    }
L_10:
	LD	IY,(IX+12)
	LEA	HL,IY+-1
	LD	BC,(IX+12)
	LD	(IX+12),L
	LD	(IX+13),H
	LD	HL,BC
	CALL	__scmpzero
	JR	Z,L_13
	LD	HL,(IX+9)
	LD	A,(HL)
	OR	A,A
	JR	NZ,L_11
L_13:
;   72	    
;   73	    return result;
	LD	HL,(IX+-2)
;   74	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _mf_get_string_width ***************************
;Name                         Addr/Register   Size   Type
;_mf_character_width                 IMPORT  -----   function
;_mf_compute_kerning                 IMPORT  -----   function
;_mf_getchar                         IMPORT  -----   function
;c2                                    IX-6      2   variable
;c1                                    IX-4      2   variable
;result                                IX-2      2   variable
;kern                                 IX+15      1   parameter
;count                                IX+12      2   parameter
;text                                  IX+9      3   parameter
;font                                  IX+6      3   parameter


; Stack Frame Size: 24 (bytes)
;       Spill Code: 0 (instruction)


;   75	
;   76	/* Return the length of the string without trailing spaces. */
;   77	static uint16_t strip_spaces(mf_str text, uint16_t count, mf_char *last_char)
;   78	{
_strip_spaces:
	LD	HL,-6
	CALL	__frameset
;   79	    uint16_t i = 0, result = 0;
	LD	(IX+-4),0
	LD	(IX+-3),0
	LD	(IX+-6),0
	LD	(IX+-5),0
;   80	    mf_char tmp = 0;
	LD	(IX+-2),0
	LD	(IX+-1),0
;   81	    
;   82	    if (!count)
	LD	HL,(IX+9)
	CALL	__scmpzero
	JR	NZ,L_24
;   83	        count = 0xFFFF;
	LD	(IX+9),255
	LD	(IX+10),255
;   84	    
;   85	    while (count-- && *text)
	JR	L_24
L_25:
;   86	    {
;   87	        i++;
	LD	HL,(IX+-4)
	INC	HL
	LD	(IX+-4),L
	LD	(IX+-3),H
;   88	        tmp = mf_getchar(&text);
	PEA	IX+6
	CALL	_mf_getchar
	POP	BC
	LD	(IX+-2),L
	LD	(IX+-1),H
;   89	        if (tmp != ' ' && tmp != 0xA0 && tmp != '\n' &&
	LD	HL,(IX+-2)
	LD.LIS	BC,32
	OR	A,A
	SBC.SIS	HL,BC
	JR	Z,L_24
	LD.LIS	BC,160
	LD	HL,(IX+-2)
	OR	A,A
	SBC.SIS	HL,BC
	JR	Z,L_24
	LD.LIS	BC,10
	LD	HL,(IX+-2)
	OR	A,A
	SBC.SIS	HL,BC
	JR	Z,L_24
;   90	            tmp != '\r' && tmp != '\t')
	LD.LIS	BC,13
	LD	HL,(IX+-2)
	OR	A,A
	SBC.SIS	HL,BC
	JR	Z,L_24
	LD.LIS	BC,9
	LD	HL,(IX+-2)
	OR	A,A
	SBC.SIS	HL,BC
	JR	Z,L_24
;   91	        {
;   92	            result = i;
	LD	BC,(IX+-4)
	LD	(IX+-6),C
	LD	(IX+-5),B
;   93	        }
;   94	    }
L_24:
	LD	IY,(IX+9)
	LEA	HL,IY+-1
	LD	BC,(IX+9)
	LD	(IX+9),L
	LD	(IX+10),H
	LD	HL,BC
	CALL	__scmpzero
	JR	Z,L_30
	LD	HL,(IX+6)
	LD	A,(HL)
	OR	A,A
	JR	NZ,L_25
L_30:
;   95	    
;   96	    if (last_char)
	LD	HL,(IX+12)
	CALL	__icmpzero
	JR	Z,L_31
;   97	    {
;   98	        if (!*text)
	LD	HL,(IX+6)
	LD	A,(HL)
	OR	A,A
	JR	NZ,L_28
;   99	            *last_char = 0;
	LD	HL,(IX+12)
	LD	(HL),0
	INC	HL
	LD	(HL),0
;  100	        else
	JR	L_31
L_28:
;  101	            *last_char = tmp;
	LD	HL,(IX+12)
	LD	A,(IX+-2)
	LD	(HL),A
	INC	HL
	LD	A,(IX+-1)
	LD	(HL),A
;  102	    }
L_31:
;  103	    
;  104	    return result;
	LD	HL,(IX+-6)
;  105	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _strip_spaces ***************************
;Name                         Addr/Register   Size   Type
;_mf_getchar                         IMPORT  -----   function
;result                                IX-6      2   variable
;i                                     IX-4      2   variable
;tmp                                   IX-2      2   variable
;last_char                            IX+12      3   parameter
;count                                 IX+9      2   parameter
;text                                  IX+6      3   parameter


; Stack Frame Size: 21 (bytes)
;       Spill Code: 0 (instruction)


;  106	
;  107	/* Render left-aligned string, left edge at x0. */
;  108	static void render_left(const struct mf_font_s *font,
;  109	                        int16_t x0, int16_t y0,
;  110	                        mf_str text, uint16_t count,
;  111	                        mf_character_callback_t callback,
;  112	                        void *state)
;  113	{
_render_left:
	LD	HL,-6
	CALL	__frameset
;  114	    int16_t x;
;  115	    mf_char c1 = 0, c2;
	LD	(IX+-4),0
	LD	(IX+-3),0
;  116	    
;  117	    x = x0 - font->baseline_x;
	LD	IY,(IX+6)
	LD	A,(IY+10)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,HL
	LD	HL,(IX+9)
	OR	A,A
	SBC.SIS	HL,BC
	LD	(IX+-2),L
	LD	(IX+-1),H
;  118	    while (count--)
	JR	L_38
L_39:
;  119	    {
;  120	        c2 = mf_getchar(&text);
	PEA	IX+15
	CALL	_mf_getchar
	POP	BC
	LD	(IX+-6),L
	LD	(IX+-5),H
;  121	        
;  122	        if (c2 == '\t')
	LD	HL,(IX+-6)
	LD.LIS	BC,9
	OR	A,A
	SBC.SIS	HL,BC
	JR	NZ,L_36
;  123	        {
;  124	#if MF_USE_TABS
;  125	            x = mf_round_to_tab(font, x0, x);
	LD	BC,(IX+-2)
	PUSH	BC
	LD	BC,(IX+9)
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_mf_round_to_tab
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-2),L
	LD	(IX+-1),H
;  126	            c1 = ' ';
	LD	(IX+-4),32
	LD	(IX+-3),0
;  127	            continue;
	JR	L_38
;  128	#else
;  129	            c2 = ' ';
;  130	#endif
;  131	        }
L_36:
;  132	        
;  133	        if (c1 != 0)
	LD	HL,(IX+-4)
	CALL	__scmpzero
	JR	Z,L_37
;  134	            x += mf_compute_kerning(font, c1, c2);
	LD	BC,(IX+-6)
	PUSH	BC
	LD	BC,(IX+-4)
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_mf_compute_kerning
	POP	BC
	POP	BC
	POP	BC
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,(IX+-2)
	ADD.SIS	HL,BC
	LD	(IX+-2),L
	LD	(IX+-1),H
L_37:
;  135	
;  136	        x += callback(x, y0, c2, state);
	LD	IY,(IX+21)
	LD	BC,(IX+24)
	PUSH	BC
	LD	BC,(IX+-6)
	PUSH	BC
	LD	BC,(IX+12)
	PUSH	BC
	LD	BC,(IX+-2)
	PUSH	BC
	CALL	__indcall
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	C,A
	LD	B,0
	LD	HL,BC
	LD	BC,(IX+-2)
	ADD.SIS	HL,BC
	LD	(IX+-2),L
	LD	(IX+-1),H
;  137	        c1 = c2;
	LD	BC,(IX+-6)
	LD	(IX+-4),C
	LD	(IX+-3),B
;  138	    }
L_38:
	LD	IY,(IX+18)
	LEA	HL,IY+-1
	LD	BC,(IX+18)
	LD	(IX+18),L
	LD	(IX+19),H
	LD	HL,BC
	CALL	__scmpzero
	JR	NZ,L_39
;  139	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _render_left ***************************
;Name                         Addr/Register   Size   Type
;_mf_compute_kerning                 IMPORT  -----   function
;_mf_getchar                         IMPORT  -----   function
;c2                                    IX-6      2   variable
;c1                                    IX-4      2   variable
;x                                     IX-2      2   variable
;state                                IX+24      3   parameter
;callback                             IX+21      3   parameter
;count                                IX+18      2   parameter
;text                                 IX+15      3   parameter
;y0                                   IX+12      2   parameter
;x0                                    IX+9      2   parameter
;font                                  IX+6      3   parameter


; Stack Frame Size: 33 (bytes)
;       Spill Code: 0 (instruction)


;  140	
;  141	#if !MF_USE_ALIGN
;  142	
;  143	void mf_render_aligned(const struct mf_font_s *font,
;  144	                       int16_t x0, int16_t y0,
;  145	                       enum mf_align_t align,
;  146	                       mf_str text, uint16_t count,
;  147	                       mf_character_callback_t callback,
;  148	                       void *state)
;  149	{
_mf_render_aligned:
	CALL	__frameset0
;  150	    int16_t string_width;
;  151	    count = strip_spaces(text, count, 0);
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+21)
	PUSH	BC
	LD	BC,(IX+18)
	PUSH	BC
	CALL	_strip_spaces
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+21),L
	LD	(IX+22),H
;  152	    render_left(font, x0, y0, text, count, callback, state);
	LD	BC,(IX+27)
	PUSH	BC
	LD	BC,(IX+24)
	PUSH	BC
	LD	BC,(IX+21)
	PUSH	BC
	LD	BC,(IX+18)
	PUSH	BC
	LD	BC,(IX+12)
	PUSH	BC
	LD	BC,(IX+9)
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_render_left
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  153	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _mf_render_aligned ***************************
;Name                         Addr/Register   Size   Type
;state                                IX+27      3   parameter
;callback                             IX+24      3   parameter
;count                                IX+21      2   parameter
;text                                 IX+18      3   parameter
;align                                IX+15      3   parameter
;y0                                   IX+12      2   parameter
;x0                                    IX+9      2   parameter
;font                                  IX+6      3   parameter


; Stack Frame Size: 30 (bytes)
;       Spill Code: 0 (instruction)


;  154	
;  155	#else
;  156	
;  157	/* Render right-aligned string, right edge at x0. */
;  158	static void render_right(const struct mf_font_s *font,
;  159	                         int16_t x0, int16_t y0,
;  160	                         mf_str text, uint16_t count,
;  161	                         mf_character_callback_t callback,
;  162	                         void *state)
;  163	{
;  164	    int16_t x;
;  165	    uint16_t i;
;  166	    mf_char c1, c2 = 0;
;  167	    mf_str tmp;
;  168	    
;  169	    /* Go to the end of the line. */
;  170	    for (i = 0; i < count; i++)
;  171	        mf_getchar(&text);
;  172	    
;  173	    x = x0 - font->baseline_x;
;  174	    for (i = 0; i < count; i++)
;  175	    {
;  176	        mf_rewind(&text);
;  177	        tmp = text;
;  178	        c1 = mf_getchar(&tmp);
;  179	        
;  180	        /* Perform tab alignment */
;  181	        if (c1 == '\t')
;  182	        {
;  183	#if MF_USE_TABS
;  184	            x = mf_round_to_prev_tab(font, x0, x);
;  185	            c2 = ' ';
;  186	            continue;
;  187	#else
;  188	            c1 = ' ';
;  189	#endif
;  190	        }
;  191	        
;  192	        /* Apply the nominal character width */
;  193	        x -= mf_character_width(font, c1);
;  194	        
;  195	        /* Apply kerning */
;  196	        if (c2 != 0)
;  197	            x -= mf_compute_kerning(font, c1, c2);
;  198	        
;  199	        callback(x, y0, c1, state);
;  200	        c2 = c1;
;  201	    }
;  202	}
;  203	
;  204	void mf_render_aligned(const struct mf_font_s *font,
;  205	                       int16_t x0, int16_t y0,
;  206	                       enum mf_align_t align,
;  207	                       mf_str text, uint16_t count,
;  208	                       mf_character_callback_t callback,
;  209	                       void *state)
;  210	{
;  211	    int16_t string_width;
;  212	    count = strip_spaces(text, count, 0);
;  213	    
;  214	    if (align == MF_ALIGN_LEFT)
;  215	    {
;  216	        render_left(font, x0, y0, text, count, callback, state);
;  217	    }
;  218	    if (align == MF_ALIGN_CENTER)
;  219	    {
;  220	        string_width = mf_get_string_width(font, text, count, false);
;  221	        x0 -= string_width / 2;
;  222	        render_left(font, x0, y0, text, count, callback, state);
;  223	    }
;  224	    else if (align == MF_ALIGN_RIGHT)
;  225	    {
;  226	        render_right(font, x0, y0, text, count, callback, state);
;  227	    }
;  228	}
;  229	
;  230	#endif
;  231	
;  232	
;  233	#if !MF_USE_JUSTIFY
;  234	
;  235	void mf_render_justified(const struct mf_font_s *font,
;  236	                         int16_t x0, int16_t y0, int16_t width,
;  237	                         mf_str text, uint16_t count,
;  238	                         mf_character_callback_t callback,
;  239	                         void *state)
;  240	{
;  241	    mf_render_aligned(font, x0, y0, MF_ALIGN_LEFT, text, count, callback, state);
;  242	}
;  243	
;  244	#else
;  245	
;  246	/* Returns true if the character is a justification point, i.e. expands
;  247	 * when the text is being justified. */
;  248	static bool is_justify_space(uint16_t c)
;  249	{
_is_justify_space:
	LD	HL,-3
	CALL	__frameset
;  250	    return c == ' ' || c == 0xA0;
	LD.LIS	BC,32
	LD	HL,(IX+6)
	OR	A,A
	SBC.SIS	HL,BC
	JR	Z,L_43
	LD.LIS	BC,160
	LD	HL,(IX+6)
	OR	A,A
	SBC.SIS	HL,BC
	JR	NZ,L_44
L_43:
;  251	}
	LD	BC,1
	LD	(IX+-3),BC
	JR	L_45
L_44:
	LD	BC,0
	LD	(IX+-3),BC
L_45:
	LD	A,(IX+-3)
	LD	SP,IX
	POP	IX
	RET	


;**************************** _is_justify_space ***************************
;Name                         Addr/Register   Size   Type
;temp46                                IX-3      3   variable
;c                                     IX+6      2   parameter


; Stack Frame Size: 12 (bytes)
;       Spill Code: 0 (instruction)


;  252	
;  253	/* Count the number of space characters in string */
;  254	static uint16_t count_spaces(mf_str text, uint16_t count)
;  255	{
_count_spaces:
	LD	HL,-2
	CALL	__frameset
;  256	    uint16_t spaces = 0;
	LD	(IX+-2),0
	LD	(IX+-1),0
;  257	    while (count-- && *text)
	JR	L_52
L_53:
;  258	    {
;  259	        if (is_justify_space(mf_getchar(&text)))
	PEA	IX+6
	CALL	_mf_getchar
	POP	BC
	PUSH	HL
	CALL	_is_justify_space
	POP	BC
	OR	A,A
	JR	Z,L_52
;  260	            spaces++;
	LD	HL,(IX+-2)
	INC	HL
	LD	(IX+-2),L
	LD	(IX+-1),H
;  261	    }
L_52:
	LD	IY,(IX+9)
	LEA	HL,IY+-1
	LD	BC,(IX+9)
	LD	(IX+9),L
	LD	(IX+10),H
	LD	HL,BC
	CALL	__scmpzero
	JR	Z,L_54
	LD	HL,(IX+6)
	LD	A,(HL)
	OR	A,A
	JR	NZ,L_53
L_54:
;  262	    return spaces;
	LD	HL,(IX+-2)
;  263	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _count_spaces ***************************
;Name                         Addr/Register   Size   Type
;_mf_getchar                         IMPORT  -----   function
;spaces                                IX-2      2   variable
;count                                 IX+9      2   parameter
;text                                  IX+6      3   parameter


; Stack Frame Size: 14 (bytes)
;       Spill Code: 0 (instruction)


;  264	
;  265	void mf_render_justified(const struct mf_font_s *font,
;  266	                         int16_t x0, int16_t y0, int16_t width,
;  267	                         mf_str text, uint16_t count,
;  268	                         mf_character_callback_t callback,
;  269	                         void *state)
;  270	{
_mf_render_justified:
	LD	HL,-16
	CALL	__frameset
;  271	    int16_t string_width, adjustment;
;  272	    uint16_t num_spaces;
;  273	    mf_char last_char;
;  274	    
;  275	    count = strip_spaces(text, count, &last_char);
	PEA	IX+-14
	LD	BC,(IX+21)
	PUSH	BC
	LD	BC,(IX+18)
	PUSH	BC
	CALL	_strip_spaces
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+21),L
	LD	(IX+22),H
;  276	    
;  277	    if (last_char == '\n' || last_char == 0)
	LD	HL,(IX+-14)
	LD.LIS	BC,10
	OR	A,A
	SBC.SIS	HL,BC
	JR	Z,L_57
	LD	HL,(IX+-14)
	CALL	__scmpzero
	JR	NZ,L_58
L_57:
;  278	    {
;  279	        /* Line ends in linefeed, do not justify. */
;  280	        render_left(font, x0, y0, text, count, callback, state);
	LD	BC,(IX+27)
	PUSH	BC
	LD	BC,(IX+24)
	PUSH	BC
	LD	BC,(IX+21)
	PUSH	BC
	LD	BC,(IX+18)
	PUSH	BC
	LD	BC,(IX+12)
	PUSH	BC
	LD	BC,(IX+9)
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_render_left
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  281	        return;
	JR	L_69
;  282	    }
L_58:
;  283	    
;  284	    string_width = mf_get_string_width(font, text, count, false);
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+21)
	PUSH	BC
	LD	BC,(IX+18)
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_mf_get_string_width
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-16),L
	LD	(IX+-15),H
;  285	    adjustment = width - string_width;
	LD	BC,(IX+-16)
	LD	HL,(IX+15)
	OR	A,A
	SBC.SIS	HL,BC
	LD	(IX+-4),L
	LD	(IX+-3),H
;  286	    num_spaces = count_spaces(text, count);
	LD	BC,(IX+21)
	PUSH	BC
	LD	BC,(IX+18)
	PUSH	BC
	CALL	_count_spaces
	POP	BC
	POP	BC
	LD	(IX+-10),L
	LD	(IX+-9),H
;  287	    
;  288	    {
;  289	        int16_t x, tmp;
;  290	        uint16_t c1 = 0, c2;
	LD	(IX+-12),0
	LD	(IX+-11),0
;  291	        
;  292	        x = x0 - font->baseline_x;
	LD	IY,(IX+6)
	LD	A,(IY+10)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,HL
	LD	HL,(IX+9)
	OR	A,A
	SBC.SIS	HL,BC
	LD	(IX+-2),L
	LD	(IX+-1),H
;  293	        while (count--)
	JR	L_67
L_68:
;  294	        {
;  295	            c2 = mf_getchar(&text);
	PEA	IX+18
	CALL	_mf_getchar
	POP	BC
	LD	(IX+-8),L
	LD	(IX+-7),H
;  296	            
;  297	            if (c2 == '\t')
	LD	HL,(IX+-8)
	LD.LIS	BC,9
	OR	A,A
	SBC.SIS	HL,BC
	JR	NZ,L_63
;  298	            {
;  299	#if MF_USE_TABS
;  300	                tmp = x;
	LD	BC,(IX+-2)
	LD	(IX+-6),C
	LD	(IX+-5),B
;  301	                x = mf_round_to_tab(font, x0, x);
	LD	BC,(IX+-2)
	PUSH	BC
	LD	BC,(IX+9)
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_mf_round_to_tab
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-2),L
	LD	(IX+-1),H
;  302	                adjustment -= x - tmp - mf_character_width(font, '\t');
	LD	BC,9
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_mf_character_width
	POP	BC
	POP	BC
	LD	C,A
	LD	B,0
	LD	HL,BC
	LD	BC,(IX+-6)
	ADD.SIS	HL,BC
	LD	BC,HL
	LD	HL,(IX+-2)
	OR	A,A
	SBC.SIS	HL,BC
	LD	BC,HL
	LD	HL,(IX+-4)
	OR	A,A
	SBC.SIS	HL,BC
	LD	(IX+-4),L
	LD	(IX+-3),H
;  303	                c1 = c2;
	LD	BC,(IX+-8)
	LD	(IX+-12),C
	LD	(IX+-11),B
;  304	                continue;
	JR	L_67
;  305	#else
;  306	                c2 = ' ';
;  307	#endif
;  308	            }
L_63:
;  309	            
;  310	            if (is_justify_space(c2))
	LD	BC,(IX+-8)
	PUSH	BC
	CALL	_is_justify_space
	POP	BC
	OR	A,A
	JR	Z,L_65
;  311	            {
;  312	                tmp = (adjustment + num_spaces / 2) / num_spaces;
	LD	BC,(IX+-10)
	CALL	__stoiu
	LD	BC,2
	CALL	__idivs
	LD	DE,HL
	LD	BC,(IX+-4)
	CALL	__stoi
	ADD	HL,DE
	LD	DE,HL
	LD	BC,(IX+-10)
	CALL	__stoiu
	LD	BC,HL
	LD	HL,DE
	CALL	__idivs
	LD	(IX+-6),L
	LD	(IX+-5),H
;  313	                adjustment -= tmp;
	LD	BC,(IX+-6)
	LD	HL,(IX+-4)
	OR	A,A
	SBC.SIS	HL,BC
	LD	(IX+-4),L
	LD	(IX+-3),H
;  314	                num_spaces--;
	LD	IY,(IX+-10)
	LEA	HL,IY+-1
	LD	(IX+-10),L
	LD	(IX+-9),H
;  315	                x += tmp;
	LD	BC,(IX+-6)
	LD	HL,(IX+-2)
	ADD.SIS	HL,BC
	LD	(IX+-2),L
	LD	(IX+-1),H
;  316	            }
L_65:
;  317	            
;  318	            if (c1 != 0)
	LD	HL,(IX+-12)
	CALL	__scmpzero
	JR	Z,L_66
;  319	            {
;  320	                tmp = mf_compute_kerning(font, c1, c2);
	LD	BC,(IX+-8)
	PUSH	BC
	LD	BC,(IX+-12)
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_mf_compute_kerning
	POP	BC
	POP	BC
	POP	BC
	LD	B,A
	SEXT	HL
	LD	(IX+-6),B
	LD	(IX+-5),H
;  321	                x += tmp;
	LD	BC,(IX+-6)
	LD	HL,(IX+-2)
	ADD.SIS	HL,BC
	LD	(IX+-2),L
	LD	(IX+-1),H
;  322	                adjustment -= tmp;
	LD	BC,(IX+-6)
	LD	HL,(IX+-4)
	OR	A,A
	SBC.SIS	HL,BC
	LD	(IX+-4),L
	LD	(IX+-3),H
;  323	            }
L_66:
;  324	
;  325	            x += callback(x, y0, c2, state);
	LD	IY,(IX+24)
	LD	BC,(IX+27)
	PUSH	BC
	LD	BC,(IX+-8)
	PUSH	BC
	LD	BC,(IX+12)
	PUSH	BC
	LD	BC,(IX+-2)
	PUSH	BC
	CALL	__indcall
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	C,A
	LD	B,0
	LD	HL,BC
	LD	BC,(IX+-2)
	ADD.SIS	HL,BC
	LD	(IX+-2),L
	LD	(IX+-1),H
;  326	            c1 = c2;
	LD	BC,(IX+-8)
	LD	(IX+-12),C
	LD	(IX+-11),B
;  327	        }
L_67:
	LD	IY,(IX+21)
	LEA	HL,IY+-1
	LD	BC,(IX+21)
	LD	(IX+21),L
	LD	(IX+22),H
	LD	HL,BC
	CALL	__scmpzero
	JR	NZ,L_68
;  328	    }
;  329	}
L_69:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _mf_render_justified ***************************
;Name                         Addr/Register   Size   Type
;_mf_compute_kerning                 IMPORT  -----   function
;_mf_character_width                 IMPORT  -----   function
;_mf_getchar                         IMPORT  -----   function
;_mf_get_string_width                IMPORT  -----   function
;string_width                         IX-16      2   variable
;last_char                            IX-14      2   variable
;c1                                   IX-12      2   variable
;num_spaces                           IX-10      2   variable
;c2                                    IX-8      2   variable
;tmp                                   IX-6      2   variable
;adjustment                            IX-4      2   variable
;x                                     IX-2      2   variable
;state                                IX+27      3   parameter
;callback                             IX+24      3   parameter
;count                                IX+21      2   parameter
;text                                 IX+18      3   parameter
;width                                IX+15      2   parameter
;y0                                   IX+12      2   parameter
;x0                                    IX+9      2   parameter
;font                                  IX+6      3   parameter


; Stack Frame Size: 46 (bytes)
;       Spill Code: 0 (instruction)


	XREF _mf_compute_kerning:ROM
	XREF _mf_character_width:ROM
	XREF _mf_getchar:ROM
	XREF __indcall:ROM
	XREF __idivs:ROM
	XREF __irems:ROM
	XREF __stoi:ROM
	XREF __stoiu:ROM
	XREF __frameset0:ROM
	XREF __frameset:ROM
	XREF __scmpzero:ROM
	XREF __icmpzero:ROM
	XDEF _mf_render_justified
	XDEF _mf_render_aligned
	XDEF _mf_get_string_width
	END
