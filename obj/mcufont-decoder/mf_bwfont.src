; Zilog eZ80 ANSI C Compiler Release 3.4
; -optsize -noreduceopt -nomodsect -peephole -globalopt
; -localcse -const=ROM 
	FILE	"SRC\MCUFONT-DECODER\MF_BWFONT.C"
	.assume ADL=1
	SEGMENT CODE
;    1	#include "mf_bwfont.h"
;    2	#include <stdbool.h>
;    3	
;    4	/* Find the character range and index that contains a given glyph.. */
;    5	static const struct mf_bwfont_char_range_s *find_char_range(
;    6	    const struct mf_bwfont_s *font, uint16_t character, uint16_t *index_ret)
;    7	{
_find_char_range:
	LD	HL,-12
	CALL	__frameset
;    8	    unsigned i, index;
;    9	    const struct mf_bwfont_char_range_s *range;
;   10	    for (i = 0; i < font->char_range_count; i++)
	LD	BC,0
	LD	(IX+-3),BC
	JR	L_5
L_3:
;   11	    {
;   12	        range = &font->char_ranges[i];
	LD	HL,(IX+-3)
	LD	A,18
	LD	IY,(IX+6)
	LD	BC,(IY+24)
	CALL	__imul_b
	ADD	HL,BC
	LD	(IX+-6),HL
;   13	        index = character - range->first_char;
	LD	IY,(IX+-6)
	LD	DE,(IY+0)
	LD	BC,(IX+9)
	CALL	__stoiu
	LD	(IX+-12),HL
	LD	BC,DE
	CALL	__stoiu
	LD	BC,HL
	LD	HL,(IX+-12)
	OR	A,A
	SBC	HL,BC
	LD	(IX+-9),HL
;   14	        if (character >= range->first_char && index < range->char_count)
	LD	HL,(IX+9)
	OR	A,A
	LD	BC,DE
	SBC.SIS	HL,BC
	JR	C,L_4
	LD	IY,(IX+-6)
	LD	BC,(IY+2)
	CALL	__stoiu
	LD	BC,HL
	LD	HL,(IX+-9)
	OR	A,A
	SBC	HL,BC
	JR	NC,L_4
;   15	        {
;   16	            *index_ret = index;
	LD	HL,(IX+12)
	LD	BC,(IX+-9)
	LD	(HL),C
	INC	HL
	LD	(HL),B
;   17	            return range;
	LD	HL,(IX+-6)
	JR	L_7
;   18	        }
;   19	    }
L_4:
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
L_5:
	LD	IY,(IX+6)
	LD	A,(IY+23)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	JR	C,L_3
	OR	A,A
;   20	    
;   21	    return 0;
	SBC	HL,HL
;   22	}
L_7:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _find_char_range ***************************
;Name                         Addr/Register   Size   Type
;index                                 IX-9      3   variable
;range                                 IX-6      3   variable
;i                                     IX-3      3   variable
;index_ret                            IX+12      3   parameter
;character                             IX+9      2   parameter
;font                                  IX+6      3   parameter


; Stack Frame Size: 27 (bytes)
;       Spill Code: 0 (instruction)


;   23	
;   24	static uint8_t get_width(const struct mf_bwfont_char_range_s *r, uint16_t index)
;   25	{
_get_width:
	LD	HL,-1
	CALL	__frameset
;   26	    if (r->width)
	LD	IY,(IX+6)
	LD	A,(IY+8)
	LD	(IX+-1),A
	OR	A,A
	JR	Z,L_9
;   27	    {
;   28	        return r->width + r->offset_x;
	LD	IY,(IX+6)
	LD	A,(IY+4)
	ADD	A,(IX+-1)
	JR	L_10
;   29	    }
;   30	    else
L_9:
;   31	    {
;   32	        return r->glyph_widths[index];
	LD	BC,(IX+9)
	LD	IY,(IX+6)
	LD	DE,(IY+9)
	CALL	__stoiu
	ADD	HL,DE
	LD	A,(HL)
;   33	    }
;   34	}
L_10:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _get_width ***************************
;Name                         Addr/Register   Size   Type
;G_0                                   IX-1      1   variable
;index                                 IX+9      2   parameter
;r                                     IX+6      3   parameter


; Stack Frame Size: 13 (bytes)
;       Spill Code: 0 (instruction)


;   35	
;   36	static uint8_t render_char(const struct mf_bwfont_char_range_s *r,
;   37	                           int16_t x0, int16_t y0, uint16_t index,
;   38	                           mf_pixel_callback_t callback,
;   39	                           void *state)
;   40	{
_render_char:
	LD	HL,-25
	CALL	__frameset
;   41	    const uint8_t *data, *p;
;   42	    uint8_t stride, runlen;
;   43	    uint8_t x, y, height, num_cols;
;   44	    uint8_t bit, byte, mask;
;   45	    bool oldstate, newstate;
;   46	    
;   47	    if (r->width)
	LD	IY,(IX+6)
	LD	A,(IY+8)
	LD	(IX+-5),A
	OR	A,A
	JR	Z,L_12
;   48	    {
;   49	        data = r->glyph_data + r->width * index * r->height_bytes;
	LD	IY,(IX+6)
	LD	A,(IY+6)
	LD	(IX+-8),A
	LD	BC,(IX+15)
	CALL	__stoiu
	LD	DE,HL
	LD	A,(IX+-5)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,DE
	CALL	__imuls
	LD	DE,HL
	LD	A,(IX+-8)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,DE
	LD	DE,(IY+15)
	CALL	__imuls
	ADD	HL,DE
	LD	(IX+-19),HL
;   50	        num_cols = r->width;
	LD	A,(IX+-5)
	LD	(IX+-9),A
;   51	    }
;   52	    else
	JR	L_13
L_12:
;   53	    {
;   54	        data = r->glyph_data + r->glyph_offsets[index] * r->height_bytes;
	LD	IY,(IX+6)
	LD	BC,(IY+12)
	LD	(IX+-25),BC
	LD	BC,(IX+15)
	CALL	__stoiu
	ADD	HL,HL
	LD	BC,(IX+-25)
	ADD	HL,BC
	LD	(IX+-22),HL
	LD	A,(IY+6)
	LD	(IX+-8),A
	LD	HL,(IX+-22)
	LD	BC,(HL)
	CALL	__stoiu
	LD	DE,HL
	LD	A,(IX+-8)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,DE
	LD	DE,(IY+15)
	CALL	__imuls
	ADD	HL,DE
	LD	(IX+-19),HL
;   55	        num_cols = r->glyph_offsets[index + 1] - r->glyph_offsets[index];
	LD	BC,(IX+15)
	CALL	__stoiu
	INC	HL
	ADD	HL,HL
	LD	BC,(IX+-25)
	ADD	HL,BC
	LD	IY,(IX+-22)
	LD	B,(IY)
	LD	A,(HL)
	SUB	A,B
	LD	(IX+-9),A
;   56	    }
L_13:
;   57	    
;   58	    stride = r->height_bytes;
	LD	A,(IX+-8)
	LD	(IX+-12),A
;   59	    height = r->height_pixels;
	LD	IY,(IX+6)
	LD	A,(IY+7)
	LD	(IX+-16),A
;   60	    y0 += r->offset_y;
	LD	C,(IY+5)
	LD	B,0
	LD	HL,BC
	LD	BC,(IX+12)
	ADD.SIS	HL,BC
	LD	(IX+12),L
	LD	(IX+13),H
;   61	    x0 += r->offset_x;
	LD	C,(IY+4)
	LD	B,0
	LD	HL,BC
	LD	BC,(IX+9)
	ADD.SIS	HL,BC
	LD	(IX+9),L
	LD	(IX+10),H
;   62	    bit = 0;
	LD	(IX+-4),0
;   63	    byte = 0;
	LD	(IX+-6),0
;   64	    
;   65	    for (y = 0; y < height; y++)
	LD	(IX+-3),0
	JR	L_34
L_32:
;   66	    {
;   67	        mask = (1 << bit);
	LD	A,1
	LD	B,(IX+-4)
	CALL	__bshl
	LD	(IX+-11),A
;   68	        
;   69	        oldstate = false;
	LD	(IX+-7),0
;   70	        runlen = 0;
	LD	(IX+-1),0
;   71	        p = data + byte;
	LD	A,(IX+-6)
	UEXT	HL
	LD	L,A
	LD	BC,(IX+-19)
	ADD	HL,BC
	LD	(IX+-15),HL
;   72	        for (x = 0; x < num_cols; x++, p += stride)
	LD	(IX+-2),0
	JR	L_24
L_22:
;   73	        {
;   74	            newstate = pgm_read_byte(p) & mask;
	LD	HL,(IX+-15)
	LD	A,(HL)
	AND	A,(IX+-11)
	LD	(IX+-10),A
;   75	            if (newstate != oldstate)
	CP	A,(IX+-7)
	JR	Z,L_21
;   76	            {
;   77	                if (oldstate && runlen)
	LD	A,(IX+-7)
	OR	A,A
	JR	Z,L_18
	LD	A,(IX+-1)
	OR	A,A
	JR	Z,L_18
;   78	                {
;   79	                    callback(x0 + x - runlen, y0 + y, runlen, 255, state);
	LD	IY,(IX+18)
	LD	BC,(IX+21)
	PUSH	BC
	LD	BC,255
	PUSH	BC
	LD	C,(IX+-1)
	LD	B,0
	PUSH	BC
	LD	C,(IX+-3)
	LD	HL,(IX+12)
	ADD.SIS	HL,BC
	PUSH	HL
	LD	C,(IX+-2)
	LD	HL,(IX+9)
	ADD.SIS	HL,BC
	LD	C,(IX+-1)
	OR	A,A
	SBC.SIS	HL,BC
	PUSH	HL
	CALL	__indcall
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;   80	                }
L_18:
;   81	                
;   82	                oldstate = newstate;
	LD	A,(IX+-10)
	LD	(IX+-7),A
;   83	                runlen = 0;
	LD	(IX+-1),0
;   84	            }
L_21:
;   85	            
;   86	            runlen++;
	INC	(IX+-1)
	INC	(IX+-2)
	LD	A,(IX+-12)
	UEXT	HL
	LD	L,A
	LD	BC,(IX+-15)
	ADD	HL,BC
	LD	(IX+-15),HL
;   87	        }
L_24:
	LD	A,(IX+-2)
	CP	A,(IX+-9)
	JR	C,L_22
;   88	        
;   89	        if (oldstate && runlen)
	LD	A,(IX+-7)
	OR	A,A
	JR	Z,L_29
	LD	A,(IX+-1)
	OR	A,A
	JR	Z,L_29
;   90	        {
;   91	            callback(x0 + x - runlen, y0 + y, runlen, 255, state);
	LD	IY,(IX+18)
	LD	BC,(IX+21)
	PUSH	BC
	LD	BC,255
	PUSH	BC
	LD	C,(IX+-1)
	LD	B,0
	PUSH	BC
	LD	C,(IX+-3)
	LD	HL,(IX+12)
	ADD.SIS	HL,BC
	PUSH	HL
	LD	C,(IX+-2)
	LD	HL,(IX+9)
	ADD.SIS	HL,BC
	LD	C,(IX+-1)
	OR	A,A
	SBC.SIS	HL,BC
	PUSH	HL
	CALL	__indcall
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;   92	        }
L_29:
;   93	        
;   94	        bit++;
	INC	(IX+-4)
;   95	        if (bit > 7)
	LD	A,7
	CP	A,(IX+-4)
	JR	NC,L_33
;   96	        {
;   97	            bit = 0;
	LD	(IX+-4),0
;   98	            byte++;
	INC	(IX+-6)
;   99	        }
;  100	    }
L_33:
	INC	(IX+-3)
L_34:
	LD	A,(IX+-3)
	CP	A,(IX+-16)
	JR	C,L_32
;  101	    
;  102	    return get_width(r, index);
	LD	BC,(IX+15)
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_get_width
	POP	BC
	POP	BC
;  103	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _render_char ***************************
;Name                         Addr/Register   Size   Type
;data                                 IX-19      3   variable
;height                               IX-16      1   variable
;p                                    IX-15      3   variable
;stride                               IX-12      1   variable
;mask                                 IX-11      1   variable
;newstate                             IX-10      1   variable
;num_cols                              IX-9      1   variable
;G_2                                   IX-8      1   variable
;oldstate                              IX-7      1   variable
;byte                                  IX-6      1   variable
;G_1                                   IX-5      1   variable
;bit                                   IX-4      1   variable
;y                                     IX-3      1   variable
;x                                     IX-2      1   variable
;runlen                                IX-1      1   variable
;state                                IX+21      3   parameter
;callback                             IX+18      3   parameter
;index                                IX+15      2   parameter
;y0                                   IX+12      2   parameter
;x0                                    IX+9      2   parameter
;r                                     IX+6      3   parameter


; Stack Frame Size: 49 (bytes)
;       Spill Code: 0 (instruction)


;  104	
;  105	uint8_t mf_bwfont_render_character(const struct mf_font_s *font,
;  106	                                   int16_t x0, int16_t y0,
;  107	                                   uint16_t character,
;  108	                                   mf_pixel_callback_t callback,
;  109	                                   void *state)
;  110	{
_mf_bwfont_render_character:
	LD	HL,-5
	CALL	__frameset
;  111	    const struct mf_bwfont_s *bwfont = (const struct mf_bwfont_s*)font;
;  112	    const struct mf_bwfont_char_range_s *range;
;  113	    uint16_t index;
;  114	    
;  115	    range = find_char_range(bwfont, character, &index);
	PEA	IX+-5
	LD	BC,(IX+15)
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_find_char_range
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-3),HL
;  116	    if (!range)
	CALL	__icmpzero
	JR	NZ,L_38
;  117	        return 0;
	XOR	A,A
	JR	L_39
L_38:
;  118	    
;  119	    return render_char(range, x0, y0, index, callback, state);
	LD	BC,(IX+21)
	PUSH	BC
	LD	BC,(IX+18)
	PUSH	BC
	LD	BC,(IX+-5)
	PUSH	BC
	LD	BC,(IX+12)
	PUSH	BC
	LD	BC,(IX+9)
	PUSH	BC
	LD	BC,(IX+-3)
	PUSH	BC
	CALL	_render_char
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  120	}
L_39:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _mf_bwfont_render_character ***************************
;Name                         Addr/Register   Size   Type
;index                                 IX-5      2   variable
;range                                 IX-3      3   variable
;state                                IX+21      3   parameter
;callback                             IX+18      3   parameter
;character                            IX+15      2   parameter
;y0                                   IX+12      2   parameter
;x0                                    IX+9      2   parameter
;font                                  IX+6      3   parameter


; Stack Frame Size: 29 (bytes)
;       Spill Code: 0 (instruction)


;  121	
;  122	uint8_t mf_bwfont_character_width(const struct mf_font_s *font,
;  123	                                  uint16_t character)
;  124	{
_mf_bwfont_character_width:
	LD	HL,-5
	CALL	__frameset
;  125	    const struct mf_bwfont_s *bwfont = (const struct mf_bwfont_s*)font;
;  126	    const struct mf_bwfont_char_range_s *range;
;  127	    uint16_t index;
;  128	    
;  129	    range = find_char_range(bwfont, character, &index);
	PEA	IX+-5
	LD	BC,(IX+9)
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_find_char_range
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-3),HL
;  130	    if (!range)
	CALL	__icmpzero
	JR	NZ,L_41
;  131	        return 0;
	XOR	A,A
	JR	L_42
L_41:
;  132	    
;  133	    return get_width(range, index);
	LD	BC,(IX+-5)
	PUSH	BC
	LD	BC,(IX+-3)
	PUSH	BC
	CALL	_get_width
	POP	BC
	POP	BC
;  134	}
L_42:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _mf_bwfont_character_width ***************************
;Name                         Addr/Register   Size   Type
;index                                 IX-5      2   variable
;range                                 IX-3      3   variable
;character                             IX+9      2   parameter
;font                                  IX+6      3   parameter


; Stack Frame Size: 17 (bytes)
;       Spill Code: 0 (instruction)


	XREF __indcall:ROM
	XREF __imuls:ROM
	XREF __bshl:ROM
	XREF __stoiu:ROM
	XREF __frameset:ROM
	XREF __icmpzero:ROM
	XREF __imul_b:ROM
	XDEF _mf_bwfont_character_width
	XDEF _mf_bwfont_render_character
	END
